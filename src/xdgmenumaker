#!/usr/bin/env python
# coding: utf-8
# vim:et:sta:sts=4:sw=4:ts=8:tw=79:

from __future__ import print_function

import os
import sys
import getopt
import xdg.DesktopEntry as dentry
import xdg.Exceptions as exc
import xdg.BaseDirectory as bd
from operator import attrgetter
from xml.sax.saxutils import escape

# ConfigParser in Python2 has been renamed to configparser (all lower case)
# in Python3. So, it's a good way to find out which Python version is being
# used.
python3 = False
try:
    import ConfigParser as cp
except ImportError:
    import configparser as cp
    python3 = True

# Under Python3, load the gtk compatibility layer
if python3:
    from gi import pygtkcompat
    pygtkcompat.enable()
    pygtkcompat.enable_gtk(version='3.0')
import gtk

seticon = False
iconsize = 16
desktop = False
submenu = True
pekwmdynamic = False

# the following line gets changed by the Makefile. If it is set to
# 'not_set' it looks in the currect directory tree for the .directory
# files. If it is actually set to something else, it looks under there
# for them, where they should be if this was installed properly
prefix = 'not_set'
if prefix == 'not_set':
    desktop_dir = '../desktop-directories/'
else:
    desktop_dir = '{}/share/desktop-directories/'.format(prefix)

if not os.path.isdir(desktop_dir):
    sys.exit('ERROR: Could not find {}'.format(desktop_dir))


class App:
    '''
    A class to keep individual app details in.
    '''

    def __init__(self, name, icon, command, path):
        self.name = name
        self.icon = icon
        self.command = command
        self.path = path

    def __repr__(self):
        return repr((self.name, self.icon, self.command,
                     self.path))


class MenuEntry:
    '''
    A class for each menu entry. Includes the class category and app details
    from the App class.
    '''

    def __init__(self, category, app):
        self.category = category
        self.app = app

    def __repr__(self):
        return repr((self.category, self.app.name, self.app.icon,
                     self.app.command, self.app.path))


class MenuCategory:
    '''
    A class for each menu category. Keeps the category name and the list of
    apps that go in that category.
    '''

    def __init__(self, category, applist):
        self.category = category
        self.applist = applist


de = dentry.DesktopEntry(filename=desktop_dir +
                         'xdgmenumaker-applications.directory')
applications = de.getName().encode('utf-8')
apps_name = applications.decode()
applications_icon = de.getIcon()
de = dentry.DesktopEntry(filename=desktop_dir +
                         'xdgmenumaker-accessories.directory')
accessories = de.getName().encode('utf-8')
accessories_icon = de.getIcon()
de = dentry.DesktopEntry(filename=desktop_dir +
                         'xdgmenumaker-development.directory')
development = de.getName().encode('utf-8')
development_icon = de.getIcon()
de = dentry.DesktopEntry(filename=desktop_dir +
                         'xdgmenumaker-education.directory')
education = de.getName().encode('utf-8')
education_icon = de.getIcon()
de = dentry.DesktopEntry(filename=desktop_dir + 'xdgmenumaker-games.directory')
games = de.getName().encode('utf-8')
games_icon = de.getIcon()
de = dentry.DesktopEntry(filename=desktop_dir +
                         'xdgmenumaker-graphics.directory')
graphics = de.getName().encode('utf-8')
graphics_icon = de.getIcon()
de = dentry.DesktopEntry(filename=desktop_dir +
                         'xdgmenumaker-multimedia.directory')
multimedia = de.getName().encode('utf-8')
multimedia_icon = de.getIcon()
de = dentry.DesktopEntry(filename=desktop_dir +
                         'xdgmenumaker-network.directory')
network = de.getName().encode('utf-8')
network_icon = de.getIcon()
de = dentry.DesktopEntry(filename=desktop_dir +
                         'xdgmenumaker-office.directory')
office = de.getName().encode('utf-8')
office_icon = de.getIcon()
de = dentry.DesktopEntry(filename=desktop_dir +
                         'xdgmenumaker-settings.directory')
settings = de.getName().encode('utf-8')
settings_icon = de.getIcon()
de = dentry.DesktopEntry(filename=desktop_dir +
                         'xdgmenumaker-system.directory')
system = de.getName().encode('utf-8')
system_icon = de.getIcon()
de = dentry.DesktopEntry(filename=desktop_dir + 'xdgmenumaker-other.directory')
other = de.getName().encode('utf-8')
other_icon = de.getIcon()
# Find out which terminal emulator to use for apps that need to be
# launched in a terminal.
# First check if the XDGMENUMAKERTERM environment variable is set and use it if
# it is.
# Then see if there is a user specified terminal emulator in the
# xdgmenumaker.cfg file.
terminal_app = os.getenv("XDGMENUMAKERTERM")
if not terminal_app:
    try:
        config = cp.SafeConfigParser()
        config.read(os.path.expanduser('~/.config/xdgmenumaker.cfg'))
        terminal_app = config.get('Terminal', 'terminal')
    # if there isn't, on debian and debian-likes, use the alternatives
    # system, otherwise default to xterm
    except (cp.NoSectionError, cp.NoOptionError) as e:
        if (os.path.exists('/etc/alternatives/x-terminal-emulator')
                and os.path.exists('/usr/bin/x-terminal-emulator')):
            terminal_app = '/usr/bin/x-terminal-emulator'
        else:
            terminal_app = 'xterm'


def main(argv):
    global desktop
    global seticon
    global iconsize
    global submenu
    global pekwmdynamic
    try:
        opts, args = getopt.getopt(argv, "hins:f:", ["help", "icons",
                                                     "no-submenu",
                                                     "pekwm-dynamic",
                                                     "size=",
                                                     "format="])
    except getopt.GetoptError:
        usage()
        sys.exit(2)
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage()
            sys.exit(0)
        elif opt in ("-i", "--icons"):
            seticon = True
        elif opt in ("-s", "--size"):
            try:
                iconsize = int(arg)
            except ValueError:
                usage()
                sys.exit('ERROR: size must be a number')
        elif opt in ("-n", "--no-submenu"):
            submenu = False
        elif opt in ("--pekwm-dynamic",):
            pekwmdynamic = True
        elif opt in ("-f", "--format"):
            desktop = arg
    if not desktop:
        usage()
        sys.exit('ERROR: You must specify the output format with -f')
    elif desktop == "blackbox":
        blackbox()
    elif desktop == "fluxbox":
        fluxbox()
    elif desktop == "windowmaker":
        seticon = False
        windowmaker()
    elif desktop == "icewm":
        icewm()
    elif desktop == "pekwm":
        pekwmmenu()
    elif desktop == "jwm":
        jwm()
    elif desktop == "compizboxmenu":
        compizboxmenu()
    elif desktop == "openbox":
        openbox()
    else:
        usage()
        sys.exit(2)


def usage():
    print('USAGE:', os.path.basename(sys.argv[0]), '[OPTIONS]')
    print()
    print('OPTIONS:')
    print('    -f, --format         the output format to use.')
    print('                         Valid options are blackbox, compizboxmenu,')
    print('                         fluxbox, icewm, jwm, windowmaker and pekwm')
    print('    -i, --icons          enable support for icons in the')
    print('                         menus. Does not work with windowmaker')
    print('    -s, --size           preferred icon size in pixels (default: 16)')
    print('    -n, --no-submenu     do not create a submenu. Does not work with')
    print('                         windowmaker')
    print('        --pekwm-dynamic  generate dynamic menus for pekwm')
    print('    -h, --help           show this help message')
    print('  You have to specify the output format using the -f switch.')
    print()
    print('EXAMPLES:')
    print('    xdgmenumaker -f windowmaker')
    print('    xdgmenumaker -i -f fluxbox')


def icon_strip(icon):
    # strip the directory and extension from the icon name
    icon = os.path.basename(icon)
    if icon.endswith('.png'):
        icon = icon.replace('.png', '')
    elif icon.endswith('.svg'):
        icon = icon.replace('.svg', '')
    elif icon.endswith('.xpm'):
        icon = icon.replace('.xpm', '')
    return icon


def icon_full_path(icon):
    # If the icon path is absolute and exists, leave it alone.
    # This takes care of software that has its own icons stored
    # in non-standard directories
    if os.path.exists(icon):
        return icon
    else:
        icon = icon_strip(icon)
        icon_theme = gtk.icon_theme_get_default()
        icon = icon_theme.lookup_icon(icon, iconsize, gtk.ICON_LOOKUP_NO_SVG)
        if icon:
            icon = icon.get_filename()
        return icon


def get_entry_info(desktopfile, ico_paths=True):
    de = dentry.DesktopEntry(filename=desktopfile)

    # skip processing the rest of the desktop entry if the item is to not be
    # displayed anyway
    onlyshowin = de.getOnlyShowIn()
    notshowin = de.getNotShowIn()
    hidden = de.getHidden()
    nodisplay = de.getNoDisplay()
    # none of the freedesktop registered environments are supported by
    # OnlyShowIn anyway:
    # http://standards.freedesktop.org/menu-spec/latest/apb.html
    # So if OnlyShowIn is set, it certainly isn't for any of the WMs
    # xdgmenumaker supports.
    if (onlyshowin != []) or (desktop in notshowin) or hidden or nodisplay:
        return None

    name = de.getName().encode('utf-8')

    if seticon:
        icon = de.getIcon()
        if ico_paths:
            icon = icon_full_path(icon)
        else:
            icon = icon_strip(icon)
    else:
        icon = None

    # removing any %U or %F from the exec line
    command = de.getExec().partition('%')[0]

    terminal = de.getTerminal()
    if terminal:
        command = '{term} -e {cmd}'.format(term=terminal_app, cmd=command)

    path = de.getPath()
    if not path:
        path = None

    # cleaning up categories and keeping only registered freedesktop.org main
    # categories
    categories = de.getCategories()
    if 'AudioVideo' in categories:
        category = multimedia
    elif 'Audio' in categories:
        category = multimedia
    elif 'Video' in categories:
        category = multimedia
    elif 'Development' in categories:
        category = development
    elif 'Education' in categories:
        category = education
    elif 'Game' in categories:
        category = games
    elif 'Graphics' in categories:
        category = graphics
    elif 'Network' in categories:
        category = network
    elif 'Office' in categories:
        category = office
    elif 'System' in categories:
        category = system
    elif 'Settings' in categories:
        category = settings
    elif 'Utility' in categories:
        category = accessories
    else:
        category = other

    app = App(name, icon, command, path)
    mentry = MenuEntry(category, app)
    return mentry


def sortedcategories(applist):
    categories = []
    for e in applist:
        categories.append(e.category)
    categories = sorted(set(categories))
    return categories


def desktopfilelist():
    # if this env variable is set to 1, then only read .desktop files from the
    # tests directory, not systemwide. This gives a standard set of .desktop
    # files to compare against for testing.
    testing = os.getenv('XDGMENUMAKER_TEST')
    if testing == "1":
        dirs = ['../tests']
    else:
        dirs = []
        # some directories are mentioned twice in bd.xdg_data_dirs, once
        # with and once without a trailing /
        for i in bd.xdg_data_dirs:
            i = i.rstrip('/')
            if i not in dirs:
                dirs.append(i)
    filelist = []
    df_temp = []
    for d in dirs:
        xdgdir = '{}/applications'.format(d)
        if os.path.isdir(xdgdir):
            for i in os.listdir(xdgdir):
                if i.endswith('.desktop'):
                    # for duplicate .desktop files that exist in more
                    # than one locations, only keep the first occurence.
                    # That one should have precedence anyway (e.g.
                    # ~/.local/share/applications has precedence over
                    # /usr/share/applications
                    if i not in df_temp:
                        df_temp.append(i)
                        filelist.append('{}/{}'.format(xdgdir, i))
    return filelist


def menu(ico_paths=True):
    applist = []
    for desktopfile in desktopfilelist():
        try:
            entry = get_entry_info(desktopfile, ico_paths=ico_paths)
            if entry is not None:
                applist.append(entry)
        except exc.ParsingError:
            pass

    sortedapplist = sorted(applist, key=attrgetter('category', 'app.name'))

    menu = []
    for c in sortedcategories(applist):
        appsincategory = []
        for i in sortedapplist:
            if i.category == c:
                appsincategory.append(i.app)
        menu_category = MenuCategory(c, appsincategory)
        menu.append(menu_category)
    return menu


def category_icon(category):
    if category == accessories:
        icon = accessories_icon
    elif category == development:
        icon = development_icon
    elif category == education:
        icon = education_icon
    elif category == games:
        icon = games_icon
    elif category == graphics:
        icon = graphics_icon
    elif category == multimedia:
        icon = multimedia_icon
    elif category == network:
        icon = network_icon
    elif category == office:
        icon = office_icon
    elif category == settings:
        icon = settings_icon
    elif category == system:
        icon = system_icon
    elif category == other:
        icon = other_icon
    else:
        icon = None
    return icon


def blackbox():
    # Blackbox menus are the same as Fluxbox menus. They just don't support
    # icons.
    global seticon
    seticon = False
    fluxbox()


def fluxbox():
    if submenu:
        spacing = '  '
        if seticon:
            app_icon = icon_full_path(applications_icon)

            if app_icon is None:
                print('[submenu] ({})'.format(apps_name))
            else:
                print('[submenu] ({}) <{}>'.format(apps_name, app_icon))
        else:
            print('[submenu] ({})'.format(apps_name))
    else:
        spacing = ''
    for menu_category in menu():
        category = menu_category.category
        cat_name = category.decode()
        if seticon:
            cat_icon = category_icon(category)
            cat_icon = icon_full_path(cat_icon)
            if cat_icon:
                print('{s}[submenu] ({c}) <{i}>'.format(s=spacing, c=cat_name,
                                                        i=cat_icon))
            else:
                print('{s}[submenu] ({c})'.format(s=spacing, c=cat_name))
        else:
            print('{s}[submenu] ({c})'.format(s=spacing, c=cat_name))
        for app in menu_category.applist:
            # closing parentheses need to be escaped, otherwise they are
            # cropped out, along with everything that comes after them
            name = app.name.decode().replace(')', '\)')
            icon = app.icon
            command = app.command
            path = app.path
            if path is not None:
                command = 'cd {p} ; {c}'.format(p=path, c=command)
            if icon is None:
                print('{s}  [exec] ({n}) {{{c}}}'.format(s=spacing, n=name,
                                                         c=command))
            else:
                print('{s}  [exec] ({n}) {{{c}}} <{i}>'.format(s=spacing,
                                                               n=name,
                                                               c=command,
                                                               i=icon))
        print('{s}[end] # ({c})'.format(s=spacing, c=cat_name))
    if submenu:
        print('[end] # ({})'.format(apps_name))


def windowmaker():
    print('"{}" MENU'.format(apps_name))
    for menu_category in menu():
        category = menu_category.category
        cat_name = category.decode()
        print(' "{}" MENU'.format(cat_name))
        for app in menu_category.applist:
            name = app.name.decode()
            command = app.command
            print('  "{n}" EXEC {c}'.format(n=name, c=command))
        print(' "{}" END'.format(cat_name))
    print('"{}" END'.format(apps_name))


def icewm():
    if submenu:
        spacing = '  '
        if seticon:
            app_icon = icon_full_path(applications_icon)
            if app_icon is None:
                app_icon = "_none_"
            print('menu "{a}" {i} {{'.format(a=apps_name, i=app_icon))
        else:
            print('menu "{}" _none_ {{'.format(apps_name))
    else:
        spacing = ''
    for menu_category in menu():
        category = menu_category.category
        cat_name = category.decode()
        cat_icon = category_icon(category)
        cat_icon = icon_full_path(cat_icon)
        if seticon and cat_icon is not None:
            print('{s}menu "{c}" {i} {{'.format(s=spacing, c=cat_name,
                                                i=cat_icon))
        else:
            print('{s}menu "{c}" _none_ {{'.format(s=spacing, c=cat_name))
        for app in menu_category.applist:
            name = app.name.decode()
            icon = app.icon
            command = app.command
            if seticon and icon is not None:
                print('{s}  prog "{n}" {i} {c}'.format(s=spacing, n=name,
                                                       i=icon, c=command))
            else:
                print('{s}  prog "{n}" _none_ {c}'.format(s=spacing, n=name,
                                                          c=command))
        print('{}}}'.format(spacing))
    if submenu:
        print('}')


def pekwmmenu():
    if pekwmdynamic:
        print("Dynamic {")
        dspacing = '  '
    else:
        dspacing = ''
    if submenu:
        spacing = '  '
        if seticon:
            app_icon = icon_full_path(applications_icon)
            print('{s}Submenu = "{a}" {{ Icon = "{i}"'.format(s=dspacing,
                                                              a=apps_name,
                                                              i=app_icon))
        else:
            print('{s}Submenu = "{a}" {{'.format(s=dspacing, a=apps_name))
    else:
        spacing = ''
    for menu_category in menu():
        category = menu_category.category
        cat_name = category.decode()
        cat_icon = category_icon(category)
        cat_icon = icon_full_path(cat_icon)
        if seticon and cat_icon is not None:
            print('{d}{s}Submenu = "{c}" {{ Icon = "{i}"'.format(d=dspacing,
                                                                 s=spacing,
                                                                 c=cat_name,
                                                                 i=cat_icon))
        else:
            print('{d}{s}Submenu = "{c}" {{'.format(d=dspacing, s=spacing,
                                                    c=cat_name))
        for app in menu_category.applist:
            name = app.name.decode()
            icon = app.icon
            # for some apps (like netbeans) the command is launched with
            # /bin/sh "command"
            # and the quotes get mixed up with the quotes pekwm puts
            # around Actions, so we're just stripping the quotes
            command = app.command.replace('"', '')
            path = app.path
            if path is not None:
                # pekwm doesn't like "cd path ; command", but it works
                # with "&&" and "||", so we'll launch the command even if the
                # path does not exist
                command = 'cd {p} && {c} || {c}'.format(p=path, c=command)
            if seticon and icon is not None:
                print('{d}{s}  Entry = "{n}" {{ Icon = "{i}"; Actions = "Exec {c} &" }}'
                      .format(d=dspacing, s=spacing, n=name, i=icon,
                              c=command))
            else:
                print('{d}{s}  Entry = "{n}" {{ Actions = "Exec {c} &" }}'
                      .format(d=dspacing, s=spacing, n=name, c=command))
        print('{d}{s}}}'.format(d=dspacing, s=spacing))
    if submenu:
        print('{}}}'.format(dspacing))
    if pekwmdynamic:
        print("}")


def jwm():
    print('<?xml version="1.0"?>')
    print('<JWM>')
    if submenu:
        spacing = '  '
        if seticon:
            app_icon = icon_full_path(applications_icon)
            if app_icon is None:
                print('<Menu label="{}">'.format(apps_name))
            else:
                print('<Menu icon="{i}" label="{a}">'.format(i=app_icon,
                                                             a=apps_name))
        else:
            print('<Menu label="{}">'.format(apps_name))
    else:
        spacing = ''
    for menu_category in menu():
        category = menu_category.category
        cat_name = category.decode()
        cat_icon = category_icon(category)
        cat_icon = icon_full_path(cat_icon)
        if seticon and cat_icon is not None:
            print('{s}<Menu icon="{i}" label="{c}">'.format(s=spacing,
                                                            i=cat_icon,
                                                            c=cat_name))
        else:
            print('{s}<Menu label="{c}">'.format(s=spacing, c=cat_name))
        for app in menu_category.applist:
            name = app.name.decode()
            icon = app.icon
            command = app.command
            path = app.path
            if path is not None:
                command = 'cd {p} ; {c}'.format(p=path, c=command)
            if seticon and icon is not None:
                print('{s}  <Program icon="{i}" label="{n}">{c}</Program>'
                      .format(s=spacing, i=icon, n=name, c=command))
            else:
                print('{s}  <Program label="{n}">{c}</Program>'
                      .format(s=spacing, n=name, c=command))
        print('{}</Menu>'.format(spacing))
    if submenu:
        print('</Menu>')
    print('</JWM>')


def openbox():
    print('<?xml version="1.0" encoding="UTF-8"?>')
    print('<openbox_pipe_menu>')
    spacing = '  '
    for menu_category in menu():
        category = menu_category.category
        cat_name = category.decode()
        cat_id = 'apps-{}-menu'.format(cat_name.lower())
        cat_icon = category_icon(category)
        cat_icon = icon_full_path(cat_icon)
        if seticon and cat_icon is not None:
            print('{s}<menu id="{d}" label="{c}" icon="{i}">'
                  .format(s=spacing, d=cat_id, c=cat_name, i=cat_icon))
        else:
            print('{s}<menu id="{d}" label="{c}">'
                  .format(s=spacing, d=cat_id, c=cat_name))

        for app in menu_category.applist:
            name = app.name.decode()
            command = app.command
            icon = app.icon
            if seticon and icon is not None:
                print('{s}  <item label="{n}" icon="{i}">'
                      .format(s=spacing, n=escape(name), i=icon))
            else:
                print('{s}  <item label="{n}">'
                      .format(s=spacing, n=escape(name)))
            print('{}    <action name="Execute">'.format(spacing))
            print('{s}      <command>{c}</command>'.format(s=spacing,
                                                           c=command))
            print('{}    </action>'.format(spacing))
            print('{}  </item>'.format(spacing))
        print('{}</menu>'.format(spacing))
    print('</openbox_pipe_menu>')


def compizboxmenu():
    if submenu:
        spacing = '  '
        if seticon:
            app_icon = icon_strip(applications_icon)
            print('<menu icon="{i}" name="{a}">'.format(i=app_icon,
                                                        a=apps_name))
        else:
            print('<menu name="{}">'.format(apps_name))
    else:
        spacing = ''
    for menu_category in menu(ico_paths=False):
        category = menu_category.category
        cat_name = category.decode()
        cat_icon = category_icon(category)
        if seticon and cat_icon is not None:
            print('{s}<menu icon="{i}" name="{c}">'.format(
                s=spacing, i=cat_icon, c=cat_name))
        else:
            print('{s}<menu name="{c}">'.format(s=spacing, c=cat_name))
        for app in menu_category.applist:
            name = app.name.decode().replace('&', '&amp;')
            icon = app.icon
            command = app.command.replace("'", "'\\''").replace('&', '&amp;')
            path = app.path
            if path is not None:
                path = path.replace("'", "'\\''")
                command = 'sh -c \'cd "{p}" ;{c}\''.format(p=path, c=command)
            if seticon and icon is not None:
                print(('{s}  <item type="launcher"><name>{n}</name>'
                       '<icon>{i}</icon>'
                       '<command>{c}</command></item>').format(s=spacing,
                                                               n=name, i=icon,
                                                               c=command))
            else:
                print(('{s}  <item type="launcher"><name>{n}</name>'
                       '<command>{c}</command></item>').format(s=spacing,
                                                               n=name,
                                                               c=command))
        print('{}</menu>'.format(spacing))
    if submenu:
        print('</menu>')

if __name__ == "__main__":
    main(sys.argv[1:])
